<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on BITPROGRAMMER</title>
    <link>https://erdotufa.github.io/post/</link>
    <description>Recent content in Posts on BITPROGRAMMER</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>tufaerdogan@gmail.com (Erdogan Tufa)</managingEditor>
    <webMaster>tufaerdogan@gmail.com (Erdogan Tufa)</webMaster>
    <lastBuildDate>Mon, 18 May 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://erdotufa.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Syndrome of the Framework Developer</title>
      <link>https://erdotufa.github.io/post/syndrome-framework-developer/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      <author>tufaerdogan@gmail.com (Erdogan Tufa)</author>
      <guid>https://erdotufa.github.io/post/syndrome-framework-developer/</guid>
      <description>&amp;ldquo;Software developer because superhero isn&amp;rsquo;t an official job title&amp;rdquo;
 After a little experience in software, sometimes as Developer we feel like superheroes (and we are!); maybe that happens after reading a book about design patterns, clean code, following blogs, twitter or famous people known in a conference; but we forget completely that we have our own brain, and then the most import thing:
 the context of our product!</description>
    </item>
    
    <item>
      <title>Sindrome da Framework Developer</title>
      <link>https://erdotufa.github.io/post/sindrome-framework-developer/</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      <author>tufaerdogan@gmail.com (Erdogan Tufa)</author>
      <guid>https://erdotufa.github.io/post/sindrome-framework-developer/</guid>
      <description>Dopo un pò di esperienza noi sviluppatori ci sentiamo come i supereroi, iniziamo qualche lettura di libri su design patterns, clean code, seguire blog, twitter o personaggi famosi conosciuti durante qualche conferenza; dimenticando completamente di avere un proprio cervello da usare, e di un&amp;rsquo;altra cosa molto importante, ovvero:
 il contesto in cui ci troviamo ed il nostro tipo di prodotto!!!
 Presi dall&amp;rsquo;entusiasmo iniziamo a pensare a tutto con design patterns ed a sviluppare qualsiasi cosa pensando come se fosse un framework.</description>
    </item>
    
    <item>
      <title>Metodi imbuto</title>
      <link>https://erdotufa.github.io/post/metodi-imbuto/</link>
      <pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate>
      <author>tufaerdogan@gmail.com (Erdogan Tufa)</author>
      <guid>https://erdotufa.github.io/post/metodi-imbuto/</guid>
      <description>Un problema ricorrente nello sviluppo sono le concatenazioni delle operazioni dove si finisce frequentemente nello stesso punto/metodo/funzione!
Solitamente accade questo:
si scrive una funzione e si inizia a riutilizzarla nei vari punti del progetto, man mano che la riutilizziamo si inizia ad aggiungere parametri, condizioni, codice nuovo che serve ad 8 dei 10 punti dove viene utilizzata ma nei 2 casi dove non serve passiamo booleane (con valori di default) per gestire queste eccezioni.</description>
    </item>
    
    <item>
      <title>Ereditarietà VS Composizione</title>
      <link>https://erdotufa.github.io/post/inheritance-vs-compositioning/</link>
      <pubDate>Thu, 14 Jun 2018 00:00:00 +0000</pubDate>
      <author>tufaerdogan@gmail.com (Erdogan Tufa)</author>
      <guid>https://erdotufa.github.io/post/inheritance-vs-compositioning/</guid>
      <description>Una domanda che affligge la nostra mente da developer da molti anni è questa:
 Devo ereditare o comporre?
 Ho sempre visto molta confusione su questo argomento tra programmatori io stesso mi ero trovato in questa situazione.
 Perché accade ciò?
 Provo a dare una spiegazione in base alla mia personale esperienza. Quando si passa da semplici &amp;ldquo;smanettoni&amp;rdquo; di codice a una programmazione più &amp;ldquo;seria&amp;rdquo; si inizia a leggere libri di Clean Code, seguire blog di tizio e caio, andare alle conferenze, eccetera.</description>
    </item>
    
    <item>
      <title>Open-Closed</title>
      <link>https://erdotufa.github.io/post/open-closed/</link>
      <pubDate>Thu, 07 Sep 2017 00:00:00 +0000</pubDate>
      <author>tufaerdogan@gmail.com (Erdogan Tufa)</author>
      <guid>https://erdotufa.github.io/post/open-closed/</guid>
      <description>La O dei principi SOLID stà per Open Closed Principle (OCP), la sua definizione tradotta in italiano é la seguente:
 Una qualsiasi entità software (classe, modulo, funzione, ecc.) dovrebbe avere meccanismi che permettono di estenderne il comportamento senza apportare modifiche al codice preesistente. Quindi Aperte alle estensioni ma chiuse alle modifiche; da qui il nome Open-Closed.
 Questo insieme alla SRP è un&amp;rsquo;altro principio molto importante. Ma come si fa ad estendere una funzionalità senza modificare il codice esistente?</description>
    </item>
    
    <item>
      <title>Single Responsibility</title>
      <link>https://erdotufa.github.io/post/single-responsibility/</link>
      <pubDate>Mon, 28 Aug 2017 00:00:00 +0000</pubDate>
      <author>tufaerdogan@gmail.com (Erdogan Tufa)</author>
      <guid>https://erdotufa.github.io/post/single-responsibility/</guid>
      <description>La S dei principi SOLID stà per Single Responsibility Principle (SRP), la sua definizione tradotta in italiano é la seguente:
 Una classe dovrebbe avere uno ed unico motivo per cambiare
 Cosa significa? Significa avere classi più piccole ognuna con una sola responsabilità! Su molti testi si trova consigliato classi di dimensioni che non superano le 100-150 righe di codice al contrario delle &amp;ldquo;God class&amp;rdquo; dove ho una classe sola che &amp;ldquo;fa tutto&amp;rdquo;, invece il consiglio è di avere il codice dove non supera la schermata vedendo tutto senza dovere scrollare col mouse.</description>
    </item>
    
    <item>
      <title>I principi SOLID</title>
      <link>https://erdotufa.github.io/post/solid-principles/</link>
      <pubDate>Sat, 05 Aug 2017 00:00:00 +0000</pubDate>
      <author>tufaerdogan@gmail.com (Erdogan Tufa)</author>
      <guid>https://erdotufa.github.io/post/solid-principles/</guid>
      <description>Nei progetti informatici il software e la sua qualità degradano con il passare del tempo, si dice che il software marcisce (&amp;ldquo;Software Rots&amp;rdquo;). Questo degrado su molti testi di informatica viene descritto come &amp;ldquo;entropia del software&amp;rdquo;.
A cosa é dovuto?  La maggioranza dei progetti parte da un idea apparentemente &amp;ldquo;semplice&amp;rdquo;, ed é questa la &amp;ldquo;fregatura&amp;rdquo;, perché non resta mai così! Solitamente ad inizio attività partiamo sempre tutti con un buon design pensando: stavolta non sbaglio !</description>
    </item>
    
    <item>
      <title>Broken windows</title>
      <link>https://erdotufa.github.io/post/broken-windows/</link>
      <pubDate>Thu, 22 Jun 2017 00:00:00 +0000</pubDate>
      <author>tufaerdogan@gmail.com (Erdogan Tufa)</author>
      <guid>https://erdotufa.github.io/post/broken-windows/</guid>
      <description>La teoria della finestra rotta è basata su un esperimento di psicologia sociale condotto nel 1969 dal professor Philip Zimbardo presso l&amp;rsquo;Università di Stanford. Egli mise due auto identiche abbandonate una nel Bronx e l&amp;rsquo;altra a Palo Alto. Quella nel Bronx venne smantellata nel giro di poche ore, mentre quella di Palo Alto rimase intatta. Allora i ricercatori decisero di fare un&amp;rsquo;altra prova rompendo un vetro del auto intatta e nel giro di poco tempo il risultato di degrado fu lo stesso di quella del Bronx.</description>
    </item>
    
    <item>
      <title>Boy Scout Rule!</title>
      <link>https://erdotufa.github.io/post/boy-scout-rule/</link>
      <pubDate>Tue, 20 Jun 2017 00:00:00 +0000</pubDate>
      <author>tufaerdogan@gmail.com (Erdogan Tufa)</author>
      <guid>https://erdotufa.github.io/post/boy-scout-rule/</guid>
      <description>I boy scout americani hanno una regola/principio, lasciare il campo più in ordine di come lo si ha trovato inizialmente. Lo stesso principio è stato ripreso dallo &amp;ldquo;Zio Bob&amp;rdquo; Robert C. Martin il quale lo ha applicato al software nel seguente modo:
 Lasciate il codice più pulito di come lo avete ritrovato!
 Molte volte ci capita di riguardare parti del codice scritto in passato ed innorridire per la sua scarsa qualità!</description>
    </item>
    
  </channel>
</rss>